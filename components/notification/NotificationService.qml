pragma Singleton
import QtQuick
import Quickshell
import Quickshell.Services.Notifications

Singleton {
    id: notificationService
    
    // Reactive properties
    property bool ready: false
    property int totalCount: 0
    property int unreadCount: 0
    property var recentNotifications: []
    property var allNotifications: []
    
    // Connect to server changes
    Connections {
        target: server
        function onTrackedNotificationsChanged() {
            updateCounts()
        }
    }
    
    function updateCounts() {
        const prevTotalCount = totalCount
        const prevUnreadCount = unreadCount
        
        if (server.trackedNotifications && server.trackedNotifications.length !== undefined) {
            totalCount = server.trackedNotifications.length || 0
            unreadCount = server.trackedNotifications.length || 0
            
            // Update allNotifications array
            let notifications = []
            for (let i = 0; i < server.trackedNotifications.length; i++) {
                notifications.push(server.trackedNotifications.get(i))
            }
            allNotifications = notifications
        } else {
            totalCount = 0
            unreadCount = 0
            allNotifications = []
        }
        
        // Note: totalCountChanged and unreadCountChanged signals are automatically 
        // generated by QML for property changes - no need to emit manually
        
        notificationsChanged()
    }
    
    // Configuration
    property int maxHistoryCount: 100
    property int maxRecentCount: 5
    property bool showPopups: true
    property bool enableSounds: false
    property int defaultTimeout: 5000 // 5 seconds
    
    // Notification urgency mapping
    readonly property var urgencyLevels: ({
        "low": 0,
        "normal": 1, 
        "critical": 2
    })
    
    // Expose server for external access  
    property bool serverEnabled: server && server.running !== undefined ? server.running : false
    
    // The notification server
    NotificationServer {
        id: server
        
        // Enable all capabilities we want to support
        bodySupported: true
        bodyMarkupSupported: true
        bodyImagesSupported: true
        imageSupported: true
        actionsSupported: true
        actionIconsSupported: true
        persistenceSupported: true
        keepOnReload: true
        
        // Extra capabilities
        extraHints: [
            "action-icons",
            "body-hyperlinks", 
            "body-markup",
            "icon-multi",
            "persistence",
            "sound"
        ]
        
        // Handle incoming notifications
        onNotification: function(notification) {
            notification.tracked = true
            
            if (showPopups) {
                showNotificationPopup(notification)
            }
        }
    }
    
    function markAsRead(notificationId) {
        // Notifications are managed by the server directly
        notificationsChanged()
    }
    
    function markAllAsRead() {
        // Notifications are managed by the server directly
        notificationsChanged()
    }
    
    function dismissNotification(notificationId) {
        const notification = getNotificationById(notificationId)
        if (notification) {
            notification.dismiss()
        }
    }
    
    function clearAll() {
        if (server.trackedNotifications) {
            for (let i = 0; i < server.trackedNotifications.length; i++) {
                server.trackedNotifications.get(i).dismiss()
            }
        }
    }
    
    function getNotificationById(notificationId) {
        if (server.trackedNotifications) {
            for (let i = 0; i < server.trackedNotifications.length; i++) {
                const notification = server.trackedNotifications.get(i)
                if (notification.id === notificationId) {
                    return notification
                }
            }
        }
        return null
    }
    
    function showNotificationPopup(notification) {
        // Request popup through the popup manager
        notificationPopupRequested(notification)
        
        // If popup manager is available, use it directly
        if (typeof NotificationPopupManager !== "undefined") {
            NotificationPopupManager.showNotificationPopup(notification)
        }
    }
    
    function getUrgencyLevel(urgency) {
        // Convert Quickshell urgency to our internal levels
        if (!urgency) return urgencyLevels.normal
        
        switch (urgency.toString()) {
            case "0": return urgencyLevels.low
            case "1": return urgencyLevels.normal  
            case "2": return urgencyLevels.critical
            default: return urgencyLevels.normal
        }
    }
    
    function getNotificationsByApp(appName) {
        return allNotifications.filter(n => n.appName === appName)
    }
    
    function getNotificationsByUrgency(urgencyLevel) {
        return allNotifications.filter(n => getUrgencyLevel(n.urgency) === urgencyLevel)
    }
    
    // Signals
    signal notificationsChanged()
    signal notificationPopupRequested(var notification)
    signal notificationCenterRequested()
    
    Component.onCompleted: {
        ready = true
    }
}